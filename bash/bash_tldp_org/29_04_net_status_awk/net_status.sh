#!/bin/bash
# connect-stat.sh
#  Note that this script may need modification
#+ to work with a wireless connection.
# INFO: instead all of this you can use `ip -s link' as a cron job of sorts

PROCNAME="wpa_supplicant"
PROCFILENAME="net/dev"                                         # Where to look.
NOTCONNECTED=85
INTERVAL=2                                            # Update every 2 seconds.

#pidno=$( ps ax | grep -v "ps ax" | grep -v grep | grep $PROCNAME |
#awk '{ print $1 }' )

# Finding the process number of 'pppd', the 'ppp daemon'.
# Have to filter out the process lines generated by the search itself.
#
#  However, as Oleg Philon points out,
#+ this could have been considerably simplified by using "pidof".
pidno=$( pidof $PROCNAME )
#
#  Moral of the story:
#+ When a command sequence gets too complex, look for a shortcut.


if [[ -z "$pidno" ]];then   # If no pid, then process is not running.
    echo "Not connected."
    # exit $NOTCONNECTED
else
    echo "Connected."; echo
fi

while [[ true ]];do       # Endless loop, script can be improved here.
    path="/proc/$pidno/$PROCFILENAME"
    if [[ ! -e "$path" ]];then
    # While process running, then "status" file exists.
        echo "Disconnected."
        exit $NOTCONNECTED
    fi

    awk '{if ($1 ~ /.+:/) print "device->"$1 " bytes_recieved->"$2 " bytes_transmited->"$10}' < "$path"
    # netstat is outdated use `ip -s' instead
    # ip -s link |  ...
    #netstat -s | grep "packets received"  # Get some connect statistics.
    #netstat -s | grep "packets delivered"
    read -t $INTERVAL -p "Hit <q> to quit: " quit
    [[ -n $quit ]] && break
    echo; echo
done

exit 0

# As it stands, this script must be terminated with a Control-C.

#    Exercises:
#    ---------
#    Improve the script so it exits on a "q" keystroke.
#    Make the script more user-friendly in other ways.
#    Fix the script to work with wireless/DSL connections.
